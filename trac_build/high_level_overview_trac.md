# Enochian On-Chain Game Overview (Trac Systems + TAP Protocol)

## Introduction and Technical Framework

This game is a fully on-chain, Enochian-themed RPG experience built on **Trac Systems** and the **TAP Protocol**. Trac Systems enables decentralized P2P gaming logic on Bitcoin L1 through programmable tokens that evolve based on player actions and peer consensus. The game's rules and state are encoded in TAP Protocol hypertoken definitions (distributed P2P specifications), and all game content (lore, dialogues, pixel art) is stored as Bitcoin Ordinal inscriptions (no IPFS, ensuring permanence). State management and game progression are handled by the **Trac P2P Network**, which maintains consensus across distributed peers through TAP Protocol validation without requiring centralized indexers. In simpler terms, the Trac P2P Network acts as the game's "engine," with each peer validating actions and maintaining synchronized state through TAP Protocol hypertoken evolution. This means *every aspect of gameplay – from player stats to dialogue libraries – lives on Bitcoin's ledger, with Trac P2P ensuring consistency and queryability through pure decentralization*.

**TAP Protocol Integration:** The TAP Protocol inherits concepts from Ordinals and Runes, but crucially it enables fully decentralized P2P gaming through programmable hypertoken evolution on Bitcoin. TAP Protocol contracts are deployed as lightweight P2P network definitions that enable cross-peer token interactions without centralized infrastructure. Once deployed, these contracts can be *invoked with a single Bitcoin transaction* that carries a small OP\_RETURN payload indicating the desired action. This design means that unlike standard Ordinals where each state change might require a new inscription, players can trigger game actions in one transaction without repeatedly inscribing data. The contract logic runs atomically during transaction processing through Trac P2P Network consensus, reading inputs (including any attached tokens or parameters) and producing deterministic outcomes (state updates or hypertoken evolution). The Trac P2P environment provides the contract with context such as the current block's data and distributed state consensus across all network peers. All state updates (e.g. reputation points, energy levels, inventory) are synchronized across the P2P network through consensus validation, keyed by structured identifiers, and only finalized after peer agreement (with consensus akin to distributed transaction finality). If a transaction's action fails validation (e.g. not enough energy or wrong timing), TAP Protocol supports a *revert* mechanism through peer consensus that gracefully undoes state changes, ensuring the distributed state remains consistent even if a player attempts an invalid action. This entire framework is trustless and verifiable – any user or auditor can join the Trac P2P Network to participate in consensus validation and reproduce the game state from the Bitcoin chain, guaranteeing transparency and security in line with Bitcoin's decentralization.

## World Theme and Governors

**Enochian Lore:** The game is set in a dark, occult 16-bit world inspired by Enochian magic. In this mythos, there are **91 Governors** – powerful otherworldly beings or "NPCs" – each governing a unique domain of knowledge or aspect of the world. (The number 91 is directly drawn from Enochian occult tradition, which speaks of 91 cosmic governors.) Each governor has distinct **lore, personality traits, and expertise** that players can discover. For example, one governor might be the *Governor of Alchemy* (lore text describing ancient transmutations), another the *Governor of War* (lore of battles and strategy), another the *Governor of Secrets* (forbidden knowledge), etc. All this narrative content (bios, dialog scripts, etc.) is **inscribed on-chain** as part of the game data. To manage large dialog libraries on-chain, content is likely compressed or split into chunks (e.g. each governor's dialogue set might be a separate ordinal text inscription). The *Trac P2P Network* can reference these on-chain data pieces deterministically through consensus validation – for instance, by storing the content in distributed peer state or by referring to inscription IDs – so that whenever a player interacts with a governor, the relevant lore/dialogue is fetched directly from the blockchain. In short, the rich storytelling is baked into Bitcoin: **no centralized server or IPFS needed**, preserving the game's lore immutably on-chain.

**Governor Reputation System:** Gameplay centers on building **reputation** with each of the 91 governors. A player's **reputation score** with a governor signifies how much that entity trusts or favors the player, unlocking deeper lore, quests, or rewards. Increasing reputation might involve completing tasks, giving offerings (tokens), or simply conversing (in an Enochian "dialogue puzzle"). Reputation is quantified and stored on-chain (e.g. an integer value in the distributed state, keyed by `rep/<playerAddress>/<govID>` in the P2P network consensus). Each governor has its own reputation scale and benefits; for instance, reaching rep level 10 with the Alchemy governor might unlock a special alchemical recipe or artifact, while maxing rep with the Governor of Secrets might reveal hidden game lore encrypted for most players.

**Interaction Cycle – 144-Block Rule:** To prevent spamming a single governor and to pace the narrative, **each governor can only be meaningfully interacted with once per 144-block cycle** (approximately once per day, since 144 Bitcoin blocks ≈ 24 hours). This means if you speak to or perform an action for Governor X, you must wait \~24 hours (144 blocks) before Governor X will respond to you again or allow another action. This rule is enforced at the smart contract level: the contract stores the last interaction block height for each player–governor pair (e.g. key `lastInteract/<player>/<govID>`). When a player attempts to interact, the contract retrieves the current block height (the Trac P2P Network provides the block height through consensus validation) and compares it with the stored last interaction height for that governor. If `currentHeight - lastInteractHeight < 144`, the contract will reject or *revert* the action (the transaction fails the game logic). This check ensures the **"once-per-day"** rule is rigidly followed by all players, and it's transparent on-chain – anyone inspecting the state can see at which block a player last engaged a governor. The one-interaction-per-day design encourages players to explore and engage with **multiple governors over time**, rather than grinding one NPC. With 91 governors available, a dedicated player could theoretically talk to each governor once in a \~day (though energy constraints, explained next, might limit doing all 91 in 24h). This creates a strategic layer: players must choose **which governors to spend their limited daily interactions on**, perhaps prioritizing those whose rewards or knowledge they currently seek.

## Energy System: 25-Point Stamina Bar

All player actions are gated by an **Energy** mechanic to further pace gameplay. Each player has an **energy bar of 25 points** maximum. Performing any significant action (like a governor interaction, a quest attempt, or a token gamble) costs energy points. The energy system prevents a player from performing actions in rapid succession without limit, introducing a resource management challenge.

**Energy Recharge Rate:** The energy bar **recharges at a rate of 1 point per 5 Bitcoin blocks**, i.e. roughly 1 energy per \~50 minutes (since Bitcoin's block time averages \~10 min). This means if a player's energy is fully depleted (0/25), it will take about 125 blocks (≈20.8 hours) to go back to full 25 energy. The figure below illustrates this regeneration schedule, showing how energy increases stepwise as blocks pass (capped at 25 points):

&#x20;*Energy regenerates by 1 point every 5 blocks (dashed red line indicates the 25-point max). Starting from 0, it takes \~125 blocks to refill completely.*

In practical terms, a player with a full bar can do a burst of up to 25 actions at once, but then must wait for recharge. Minor breaks in play (a few hours) will restore a few energy points, allowing a handful of extra actions later in the day. This design rewards players who **check in regularly** (to use newly regenerated energy) and balances play for both casual and hardcore players. It also synergizes with the 144-block governor cycle: even if one wanted to talk to many governors in one day, energy will likely be the limiting factor that forces prioritization.

**Implementation:** The energy mechanism is implemented via on-chain state and calculated on the fly during action execution. The contract stores each player's **current energy and last energy update block** (e.g. `energy/<player>` and `energyLastUpdate/<player>`). When a player attempts an action, the contract does the following: (1) compute how many blocks have passed since `energyLastUpdate` and convert that to energy points gained: `pointsGained = floor((currentBlockHeight - energyLastUpdate) / 5)`. (2) Add `pointsGained` to the stored energy (capped at 25). (3) Update `energyLastUpdate` to reflect the blocks consumed for this recharge (or to current height if fully recharged). This effectively simulates continuous regeneration without needing to update every block. Because the current block height is available through Trac P2P Network consensus validation, the contract can reliably calculate regeneration at the moment of player action. If the player has enough energy for the attempted action (e.g. an interaction costs 1 energy, some special quests might cost more), the energy is **deducted** and the action proceeds; otherwise the contract will reject the action for insufficient stamina. The updated energy value is then stored back on-chain. All these state transitions – energy deductions and timestamp updates – are handled in the Trac P2P Network's distributed consensus, using efficient peer validation and only committing if consensus succeeds (*ensuring no partial energy drain occurs on a failed attempt*). Energy values are per player and can be queried by the game interface at any time by reading the distributed state (e.g. the front-end can query P2P network consensus to get `energy/<player>`). This lets the UI display the current energy bar and even a countdown (based on blocks) to the next energy point.

## Enochian Tokens: Currency and Economy

**Token Role:** The game's primary currency is the **Enochian Token** – a fungible in-game token required for most actions. In the occult narrative, these tokens might be imagined as "Enochian sigils" or magical energy units that must be expended to influence the governors. From a gameplay perspective, **every meaningful action costs a certain number of Enochian tokens** (for example, initiating a dialogue or quest might cost 1 token, while a higher-stakes ritual or a gamble roll might cost more). Upon use, the tokens are **burned** (removed from circulation), acting as a sink to control token supply. Players can earn Enochian tokens through gameplay and can also obtain them via purchase (supporting a free-to-play but "pay-to-speed-up" model).

**On-Chain Token Implementation:** The Enochian token is implemented as a TAP Protocol hypertoken. In TAP Protocol, every hypertoken inherently supports P2P evolution and cross-peer interactions (it has distributed state management and can interact with other hypertokens). We leverage this by either: (a) making the main game contract itself represent the Enochian hypertoken (so players' token balances are tracked in distributed P2P state), or (b) deploying a dedicated hypertoken definition and having the game contract interact with it. Either way, standard token operations are possible: minting new tokens, transferring tokens, and burning tokens are achieved through P2P consensus within transactions. For instance, when a player performs an action requiring tokens, the transaction will include an *input UTXO carrying the player's Enochian tokens*, which the contract will consume. The contract can then either not re-create those tokens in any output (effectively burning them from the supply) or explicitly invoke a burn operation. If the action succeeds, the token UTXO is consumed with no return, meaning those tokens are burned as intended. (If the action fails or is invalid, the TAP Protocol revert logic will ensure the token UTXO is returned to the player via peer consensus validation, so players don't accidentally lose tokens on a failed attempt.) The TAP Protocol model lets us bundle token transfer and hypertoken evolution in one atomic Bitcoin transaction – players don't need to trust an external custodian; the Bitcoin transaction itself carries the token burn and game call together.

**Token Treasury and Rewards:** The game uses a **Treasury system** to manage token distribution and long-term economy. At launch, a fixed **initial supply** of Enochian tokens will be created, and a large portion will reside in the Treasury (an address or contract controlled by the game logic). The Treasury's purpose is to **reward players over time** and to stabilize the economy by reintroducing tokens that have been removed by burns. As players progress, they hit certain **milestones** (e.g. reaching reputation level thresholds, completing chapters of lore, achieving first-time discoveries) which trigger token rewards from the Treasury. Additionally, some tokens from the Treasury are sold to players in token sales to support the game (monetization), and some may be reserved for the development team or future events. The Treasury is programmed (via the smart contract) to **periodically redistribute** tokens in various ways:

* **Daily/Weekly Rewards:** The contract could issue a small stipend to active players or a reward pool that gets split among players who achieved specific goals in that period.
* **Milestone Rewards:** One-time payouts when a player's on-chain state indicates a milestone (e.g. first time reaching 10 reputation with any governor yields 50 tokens).
* **Jackpot/Gambling Payouts:** (explained below) When players win in the game's chance-based mechanics, the prize tokens come from the Treasury's pool.
* **Event Rewards:** Special on-chain events (perhaps tied to Bitcoin block events or scheduled story events) where the Treasury unlocks some tokens to players.

All token movements are orchestrated by contract rules and recorded on-chain for transparency. The Treasury itself can be an Alkanes contract or simply a pool whose logic is part of the main game contract (e.g. the game contract might hold the Treasury balance and only disburse according to rules, without a human in the loop).

**Gambling Mechanics – "Roll" Allocation:** To add a casino-like thrill, the game features a *dice roll* gambling system where players can wager Enochian tokens for a chance at a larger payoff. For example, a player might spend 5 tokens to perform an "Occult Ritual Roll" – the outcome is determined pseudo-randomly, and the player either loses those tokens (a failed ritual) or gains a reward (could be a multiple of the wager in tokens, or a rare artifact). This is essentially a smart contract lottery. The **deterministic RNG** for these rolls is derived from Bitcoin's unpredictable block data: when an action requires a random outcome, the contract can pull bits from the current block's hash or coinbase nonce as a randomness source. For instance, the contract may combine the current block's nonce and the player's input (plus perhaps the governor's ID or other salt) to generate a pseudo-random number that all indexers will compute the same way. Because block hashes are practically unpredictable before the block is mined, this provides a fair source of randomness that neither players nor developers can rig (while still being verifiable after the fact). The outcomes of these rolls (win or loss) are computed in the Alkanes contract deterministically from that random seed. If it's a win, the contract mints an appropriate number of new tokens from the Treasury to the player as the prize; if a loss, the wagered tokens are burned (in effect, transferred to a burn address or simply not re-output by the contract). Over time, if designed with a small house edge, this mechanism serves as both a **fun gameplay feature** and a **token sink**: many players will burn tokens in gambles, while occasional winners get large payouts (from the Treasury). The house edge (excess tokens burned over tokens paid out) can be tuned so that, for example, 5% of tokens wagered are effectively removed from the economy, helping counter inflation.

**Token Flow Diagram:** The following diagram summarizes the flow of Enochian tokens through the game economy:

&#x20;*Enochian token economy flows. The Treasury distributes tokens to players (via initial sales and gameplay rewards). Players spend tokens in the game (interactions, gambles), and those spent tokens are burned (removed from supply). The Treasury periodically injects tokens back as rewards or jackpot payouts to winners, ensuring the economy can sustain itself over time.*

In the above model, the **initial token supply** might be, for example, **10,000,000 Enochian tokens**. A possible allocation could be: 50% (5,000,000) allocated to the Treasury for ongoing rewards, 30% (3,000,000) for public sale to fund the project (released gradually), and 20% (2,000,000) reserved for development, marketing, or ecosystem grants. This supply is **fully on-chain** – the token is minted via the Alkanes contract at genesis. (Notably, Alkanes' first contract *DIESEL* demonstrated a creative supply mechanism by minting tokens equal to the Bitcoin block reward each block; for our purposes, we choose a fixed supply model for stability, though we could also emulate a block-linked mint schedule for the game token if desired.)

**Sustainability Considerations:** With the economy design above, token **sinks** (action costs, gambles) continuously remove tokens, while controlled **sources** (Treasury rewards, possibly very small inflation) reintroduce tokens. For sustainability, the aim is to roughly balance long-term token generation and burning. For example, if on average each active player burns 10 tokens per day through gameplay, and we have 1,000 active players, that's 10,000 tokens burned daily. The Treasury's release schedule should be calibrated to replenish maybe 8,000–10,000 tokens per day (through rewards and events) to prevent the economy from running dry too fast. If tokens become scarce, new players would struggle to play (violating free-to-play ethos), whereas if tokens oversupply, they lose value and the play-to-earn aspect suffers. The contract might even adjust reward rates based on the total token burn rate (this could be automated since all burns are tracked on-chain by the indexer). Ultimately, the initial supply and Treasury could sustain the economy for a long time if tuned well – for instance, 5 million tokens in Treasury with a net burn of 2,000 per day would last \~2500 days (\~7 years) before depletion, not counting any tokens recirculated from purchases or any additional token mints that a governance might introduce later. The game's economy thus is *closed-loop on-chain*: **players are incentivized to obtain tokens (by playing or buying) to progress, and their usage of tokens fuels the scarcity and value of the token, which in turn justifies the rewards.**

Below is a summary of the token supply and distribution plan (example values for illustration):

| **Token Supply & Allocation**   | **Amount**                                      | **Notes**                                                                                                                                                                  |
| ------------------------------- | ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Initial Total Supply**        | 10,000,000 ENO                                  | Fixed at launch inscribed on-chain (could be adjusted by governance if needed in future).                                                                                  |
| **Treasury Allocation**         | 5,000,000 (50%)                                 | Held by on-chain Treasury contract for gameplay rewards, milestone payouts, and jackpot reserves. Distributed gradually per rules.                                         |
| **Public Sale Allocation**      | 3,000,000 (30%)                                 | Sold to players to fund development (possibly in phases). Also acts as initial circulating supply for players who want to buy instead of grind.                            |
| **Team & Reserve**              | 2,000,000 (20%)                                 | Locked or vested for developers, future events, marketing, and unforeseen needs. Ensures long-term support.                                                                |
| **Token Cost per Action**       | 1 ENO (basic action) up to 5+ ENO (special)     | The cost in tokens for various actions. Basic interactions cost 1; high-stakes gambles or special quests might cost more. These costs can be tuned to balance token sinks. |
| **Energy Regen Rate**           | 1 ENO per action *and* 1 energy point           | Energy cost is separate (must have energy too). Energy regenerates (see above), tokens do not – they must be earned or purchased.                                          |
| **Treasury Replenishment Rate** | \~8k–10k ENO/day (target)                       | Target average tokens paid out daily via all rewards (less than or equal to average tokens burned per day to avoid inflation). Tuning this keeps economy stable.           |
| **RNG Payout Odds**             | e.g. 30% chance 2x payout, 5% chance 10x payout | Example odds for gamble; expected value <100% of wager (house edge) so that on average the Treasury gains tokens.                                                          |

The above numbers are adjustable – they illustrate one balanced approach. Because all token transactions and supply info are available on-chain, **players can verify the tokenomics** (e.g. checking the Treasury balance or how many tokens have been burned so far) via the block explorer or by querying the MetaShrew indexer. This transparency builds trust that the game economy is not being manipulated off-chain.

## Smart Contract Interfaces and Player Actions

The heart of the game logic resides in the TAP Protocol hypertoken definitions, which define various **interfaces (functions)** for player actions. These "functions" aren't called like in Ethereum (since Bitcoin doesn't have an EVM), but conceptually they behave similarly: a player crafts a Bitcoin transaction with a specific OP\_RETURN instruction and required inputs, and the Trac P2P Network interprets it as calling a particular game action. We define an **interface-first design**, meaning we specify clearly what each action requires as input and what it does (output), focusing on the player's perspective and external behavior.

Key contract interactions include: **interacting with a governor**, **spending tokens on a gamble**, and receiving or using items (artifacts). The table below outlines the primary game actions and their input/output specifications:

| **Action (Game Function)**                                                                    | **Inputs & Requirements**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | **Outcome / Effect**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **InteractGovernor(govId)**<br>*Build reputation via dialog or tasks with a chosen Governor.* | - **Parameters:** `govId` (which of the 91 governors to approach).<br>- **Requires:** Player has ≥1 energy and ≥1 Enochian token for the interaction fee.<br>- **Once-per-cycle:** Must be ≥144 blocks since this player last interacted with this `govId` (enforced by contract using stored timestamp).<br>- **Transaction Inputs:** (a) An input UTXO from player containing at least 1 ENO token (which will be burned), (b) OP\_RETURN data encoding function "INTERACT" and the `govId`.                                                            | - **Token Burn:** Consumes the 1 ENO token from the input (burned on success).<br>- **Energy Cost:** Deducts 1 energy from player's energy bar in state.<br>- **Reputation Gain:** Increases the player's rep with the specified governor (e.g. +1 rep, or more if certain conditions met). This is stored on-chain (e.g. `rep/<player>/<govId>` incremented).<br>- **Dialogue & Outcome:** Triggers a deterministic pseudo-random event path using the governor's dialog library. The contract will use the current block's nonce/hash to pick one of several possible responses or mini-quests from that governor. The response text (stored on-chain) is not directly emitted on-chain (that would be too large), but the contract can output an index or pointer to the dialog line, which the front-end uses to fetch the actual inscribed text. For example, the contract might output an event code like "G5\_OUTCOME\_B", meaning Governor 5 (if IDs are 0-indexed) second outcome branch – the front-end then knows to display the corresponding on-chain dialogue.<br>- **Follow-up Effects:** Some interactions might yield additional effects: e.g. if this interaction completes a quest, the contract could award an **artifact NFT** (see Artifact section) by minting it to the player's address. Or, if the RNG roll indicates a rare boon, the contract might give bonus Enochian tokens (minted from Treasury to player) or a clue (which could be an encrypted message inscribed and now unlocked for the player). All such effects are deterministic and logged. |
| **GambleRoll(amount)**<br>*Wager tokens for a chance at a reward.*                            | - **Parameters:** `amount` (the number of ENO tokens the player bets). Could also implicitly use the UTXO value to determine this.<br>- **Requires:** Player has ≥1 energy (some energy cost, possibly 1 per gamble) and at least the wager amount in tokens.<br>- **Transaction Inputs:** (a) UTXO with `amount` ENO from player, (b) OP\_RETURN indicating "GAMBLE" and possibly the game type or a nonce.                                                                                                                                              | - **Token Burn or Prize:** A deterministic random draw is computed (using block hash/nonce). If the result is a **loss**, the `amount` tokens are burned (the input ENO UTXO is consumed with no output return). If the result is a **win**, the contract mints a reward to the player. For example, a win might return the original wager plus a prize (say, 2× or 5× the amount) from the Treasury's token reserve. The output would be a new UTXO to the player containing the prize tokens. This all happens in one transaction – effectively transferring tokens from the Treasury pool to the player.<br>- **Energy Cost:** Deduct 1 energy (or more for certain high stakes) from the player's energy bar in state, similar to interactions.<br>- **Logging:** The outcome (win/loss and amount) is recorded in the state log (e.g. increment a counter of wins for the player, or store this event in `log/<player>/<index>`).<br>- **Fairness:** The use of block data for RNG ensures fairness. The outcome can be verified by anyone by looking at the block hash used and seeing how the contract's RNG logic would produce the result.                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **ClaimReward(milestone)**<br>*Claim token reward from treasury after reaching a milestone.*  | - **Parameters:** `milestone` (could be an ID for the type of milestone, e.g. "rep\_level\_10" or similar).<br>- **Requires:** Player's state meets the milestone condition (checked in contract, e.g. `rep/<player>/*` values or flags indicate the milestone is achieved). Also likely requires an energy point (to perform the claiming action) to avoid spamming.<br>- **Transaction Inputs:** OP\_RETURN with "CLAIM" and milestone ID; no token input required (claim doesn't cost tokens, it *gives* tokens). Possibly a small BTC input for fees. | - **Verification:** Contract verifies the player indeed qualifies for the milestone (all on-chain: e.g. if milestone is reaching rep 10 with any governor, the contract checks the stored rep values). If not qualified or already claimed, the contract will revert (and log an attempt).<br>- **Token Payout:** The contract mints the reward amount of ENO tokens from the Treasury allocation to an output UTXO for the player. (The supply was pre-allocated, so this is just transferring from Treasury to player; it might reduce an internal counter of available rewards.)<br>- **One-Time Flag:** Marks this milestone as claimed in the player's state (e.g. set `claimed/<player>/<milestone>` = true) to prevent re-claiming.<br>- **No Burn:** No tokens are burned here (this is a source, not a sink). The only "cost" might be the 1 energy used to claim. This encourages players to actively claim their rewards rather than hoard milestones.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

*Table: Key player actions with inputs and outcomes. All actions are executed via TAP Protocol in a single Bitcoin transaction that contains the required tokens and data, ensuring atomic updates to game state.*

**Additional Functions:** The above are the core loops. Other interface functions can exist, such as **UseArtifact(artifactId)** (if certain artifacts need to be activated via contract to grant a benefit or trigger content) or **TransferArtifact** (though artifact trading can usually be done simply by sending the Ordinal/NFT to another wallet without contract involvement, since the NFT is a token itself). There may also be admin or governance functions (e.g. to top-up the Treasury, or to tweak reward rates) – these would be restricted to the game developers or a DAO multi-sig and not accessible to normal players.

**Input/Output Mechanics:** It's worth emphasizing how a single Bitcoin transaction can carry these function calls. The OP\_RETURN in the transaction typically encodes a short command (perhaps an  opcode or a structured message that the Alkanes contract's parser understands) indicating which function to execute and any parameters (like governor ID or amounts). The transaction's inputs provide the resources: the player's UTXOs with the necessary ENO tokens (and a UTXO with some BTC to pay miner fees of course). The transaction's outputs are pre-constructed to account for possible outcomes: Alkanes uses a design where you predefine a **"success output"** and a **"failure output"** when you construct the transaction. For example, if calling `InteractGovernor`, you might pre-define a success output that sends an NFT to the player (in case the contract mints one), and a failure output that returns the ENO token back to the player (in case the contract aborts due to, say, the 144-block rule or insufficient energy). The contract's execution in the indexer will determine which output path is taken. If all conditions are met (success case), the success output is "activated" (e.g. the NFT is actually assigned to it and the ENO input is consumed). If conditions fail, the contract invokes a revert, and the indexer ensures the failure output (returning the unspent token) is the one that remains. This clever mechanism allows the **Bitcoin transaction to be constructed and signed by the player *before* knowing whether the game action will succeed**, yet ensures the player doesn't lose assets on a failed action – the unwanted outcome simply doesn't get applied by the indexer logic. All state changes (rep increases, energy reductions, etc.) occur only in the distributed P2P network state and only on success (committed through peer consensus at transaction finalization) – if reverted, those changes are discarded and the distributed state remains unchanged. This approach is *analogous to a try-catch transaction with no side effects on failure*, realized purely via on-chain rules and the MetaShrew indexer's deterministic execution.

**Logging and Record-Keeping:** Every player action leaves a trace in the on-chain state, which serves as a log for both game progression and debugging. The contract keeps structured logs in the key–value store. For instance, it might maintain a sequential log for each player (like `log/<player>/0`, `log/<player>/1`, etc.) where each entry might contain a compact encoding of what happened (e.g. "at block N, interacted with Gov5, outcome B, +rep, -1 token"). Because storing large logs for every action could bloat the state, another strategy is to log only significant events or aggregate counts (e.g. track total interactions count, last interaction outcome, number of wins/losses in gambling, etc.). The MetaShrew indexer library provides conveniences like composite keys to manage such structured data (for example, using `Index.keyFor(prefix, id)` to concatenate keys for lists or mapping). This makes it straightforward to implement per-player lists or per-governor records. Additionally, the contract can utilize a **console log** for off-chain debugging (MetaShrew allows printing to console during simulation), but those do not persist on-chain. For persistent logs that the game (and players) can reference, the state keys are the source of truth.

From a user's perspective, the game's interface could present a "journal" or history of their actions by reading these on-chain logs. For example, when you open your in-game journal, the front-end will fetch entries from `log/<yourAddress>/*` and display a human-readable history of your key interactions and achievements. Because the logs are on-chain, even if the game developers went away, players could reconstruct their progress by directly querying the blockchain data via the indexer – a hallmark of a true autonomous world.

## On-Chain Content: Dialogues, Lore, and Encryption

One of the ambitious aspects of this game is that **all content – including large dialogue trees, lore text, and even graphics – is fully on-chain**. This ensures longevity and trustlessness (no one can alter or remove the lore once inscribed). However, storing large amounts of text or image data on Bitcoin is costly and requires careful structuring. Here's how the game handles content:

**Dialogue Library Architecture:** Each of the 91 governors has a **library of dialogues and story events**. These include things like flavor text when you meet them at low reputation, quest instructions, responses to certain player choices, and high-rep revelations. The volume of text is potentially large (imagine dozens of paragraphs per governor). To manage this, content is likely **fragmented into multiple Ordinal inscriptions** and **compressed**. For example, the developers might inscribe a single compressed JSON or plaintext file per governor containing all that governor's dialog/script, or break it further into chunks (e.g. by chapter or by rep level). Each such piece gets an Ordinal ID (txid and offset). The Alkanes contract might not itself decompress large text (as that could be too heavy for the WASM and unnecessary to do on-chain), but it can store references (IDs/hashes) and small identifiers for specific lines. The actual rendering of dialogue happens off-chain in the front-end: the contract might output "Governor5\_Line7" as an event, and the front-end knows to retrieve the content of line 7 from Governor5's inscribed dialogue file and display it to the player. Since all players have access to the same on-chain library, this is **deterministic and fair** (no secret content except what's encrypted, see below), yet it allows *some unpredictability*. The unpredictability comes from the **random branching**: when a governor interaction occurs, the contract may randomly choose one of several possible lines or narrative branches (weighted by player's rep or other factors). Because the random seed is derived from the fresh block, players cannot fully predict which branch they'll get on each interaction – it might be a friendly hint, a cryptic riddle, or even a setback. Yet this randomness is *deterministic in retrospect*: given the block hash, anyone can verify that the branch chosen was the correct one per the contract's logic. This approach yields a **"large, deterministic yet unpredictable"** dialog system: the library of all possible dialogues is finite and on-chain (deterministic), but the path an individual player experiences can vary (unpredictable) based on on-chain random draws. This dramatically increases replayability and emergent storytelling without requiring off-chain content.

To manage such a system, the dialog scripting might use a **state machine** or **decision tree** approach. For instance, each governor's script could be organized into states (perhaps corresponding to reputation tiers or quest progress). At an interaction, the contract knows the player's current state with that governor (e.g. `state/<player>/<gov>` might store a small state ID like 0 = initial, 1 = quest given, 2 = quest completed, etc.). The contract then selects from the appropriate set of lines for that state. Within those, if multiple outcomes are possible, it uses RNG to pick. It then updates the state if needed (for example, if a quest was given, state moves from 0 to 1, or if a quest completed, state moves to 2, etc.) along with updating rep. All these state transitions and content indices are logged. The actual text doesn't need to be emitted; the contract just needs to output enough info for the client to know what to display. In summary, **the narrative content is fully stored on Bitcoin, but the execution of it (which line to show when) is handled by the contract logic using on-chain state and randomness**. This means every player's narrative path is an emergent property of on-chain data – a true on-chain RPG storyline.

**Encrypted Secret Content:** Some game content is meant to be secret or personalized – for example, perhaps each player eventually receives a unique "Enochian Key" phrase or a secret piece of lore only they (or a small group) should know, which could be used in puzzles or just as a personalized storyline. Since all data is on-chain and public, the only way to have "secret" content is through **encryption**. The game employs encryption for content that should only unlock under certain conditions (like possessing a specific artifact NFT or reaching a certain achievement). Here's how it works:

* A piece of content that needs gating (say a hidden lore chapter or a private message from a governor) is **inscribed on-chain in encrypted form**. For instance, an Ordinal might contain `encrypted("The true name of the Governor is XYZ...")` using some symmetric cipher.
* The decryption key for that content is not published. Instead, the key is tied to a condition. For example, the key might be revealed only when a player has a particular on-chain asset (like a special NFT "Key of Secrets") *and* triggers a certain event.
* One approach is to use the player's own keys: For truly personal secrets, the content could be encrypted with the player's public key such that only their private key can decrypt it. For example, if the player's wallet uses a known public key (or we request them to provide a public key for encryption purposes), the game could derive a symmetric key or use the public key to encrypt content specifically for that player. When the time comes to unlock, the contract could either simply signal "now content X can be decrypted" and the player's client will use their private key to decrypt it (since they have had the ciphertext all along on-chain), or the contract could output an encrypted key that only the player can decode. Because Bitcoin scripting can't do heavy encryption itself, this likely relies on the front-end to perform the decryption once the key is known or provided.
* For content that is **shared among all players once unlocked** (e.g. a global secret that the whole community uncovers after someone triggers it), the encryption can be simpler: the content is inscribed encrypted, and when the first player to solve a quest triggers it, the contract could publish the decryption key openly (in an OP\_RETURN perhaps). Once that key is on-chain, anyone can decrypt the content. This would be a dramatic "reveal event" in the game's story.
* For content that is **unique per player**, using per-wallet encryption as described is ideal. Alternatively, the contract might mint an NFT that *contains* the secret in encrypted form – e.g. the NFT's inscription content might be an encrypted message – and when the player obtains it, the act of obtaining it (and perhaps an additional step where the contract gives them the key in a per-user manner) allows them to decrypt it. However, if that NFT is transferable, the secret goes with it (unless the key is kept separate).
* **Key Reset or Persistence:** The design allows possibly for key resets – for instance, if a secret is tied to an NFT and the NFT is sold, the new owner might either get a new encrypted version of the content (the game could inscribe a fresh encryption for the new owner) or the same key if the secret is meant to transfer. The "wallet-bound triggers" mentioned suggest that certain secrets are bound to a wallet – meaning even if someone else acquires the related asset, they might not get the secret content unless the game explicitly re-issues it for them. This could be implemented by having the contract check on certain events (like transfer of a particular NFT) and if the new owner hasn't seen the content, issue a transaction that provides the decryption key for the new owner (perhaps encrypted with their public key).
* **Decryption in Practice:** Suppose a secret scroll is encrypted and inscribed. When a player meets the conditions, the contract could do something like output the plaintext key XORed with the player's address (just as an example of encoding) or simply output the key encrypted with the player's pubkey (if available in a P2TR output or if the player provided it). The player's client would detect this output addressed to them, decrypt it with their private key, and obtain the secret key to the scroll. Then the client can decrypt the scroll's text and display it. If the system is designed such that even the act of outputting the key is not easily readable by others (for example, encrypted to the player's pubkey), then the secret remains fairly safe from other players – essentially **only the intended player can read the message**, fulfilling the idea of personal secret content.
* In case a player loses access (say they lose the NFT or their keys), the game may allow a "reset" – perhaps via a support process or a contract function that re-encrypts the content for a new key (this would likely require some trust or multi-sig approval if it's outside normal game logic, to prevent abuse).

In summary, encryption is used to ensure that **some content is only revealed when and to whom it's supposed to be**, despite the underlying data being on a public ledger. This adds a layer of mystery and personalization to the on-chain game: two players might see completely different secret messages even if they follow the same path, because their unique keys unlock different facets – or one might unlock something before others do. The game design contemplates both **shared unlocks** (community solves a puzzle and everyone gets the plaintext after a key revelation) and **individual unlocks** (personalized secrets tied to your identity in the game).

## Artifact NFTs and On-Chain Items

Beyond tokens, the game features **collectible artifact NFTs** – special one-of-a-kind or limited-run items that players can earn and trade. These artifacts are integral to gameplay, offering various benefits or simply serving as trophies. Each artifact is an Ordinal-based **NFT inscribed on-chain** (likely also implemented via Alkanes or at least tracked by the MetaShrew indexer as an asset). They might have 16-bit pixel art images (fitting the SNES aesthetic) associated with them, also stored on-chain. Examples of artifacts could be: *"Ring of Solomon" (boosts your reputation gains), "Seal of a Governor" (required to access a hidden area of lore), "Enochian Codex" (an item that automatically regenerates energy faster or reduces token costs),* etc.

**Earning Artifacts:** Artifacts are awarded through **milestones or rare quest outcomes**. Milestones might be things like reaching a certain rep level with a governor or completing a major story arc – the contract will then mint the corresponding NFT to the player. Rare outcomes could be tied to RNG; for instance, perhaps each interaction with the Governor of Treasures has a 1% chance to drop a random artifact NFT. Because the Alkanes contract can call minting of other asset contracts or even deploy new asset contracts, it's feasible to mint an NFT directly to a player as part of a transaction (the Alkanes standard allows a contract to output other assets under certain rules). Alternatively, the artifact could be pre-inscribed (like the developers have inscribed 100 unique artifact Ordinals and the contract simply "assigns" one to a player by revealing a transfer code or a binding to their address). But a more straightforward approach is to treat each artifact type as its own Alkanes asset with limited supply (maybe minted on demand when someone wins it). For truly unique items, the contract might simply never mint more than one.

**Artifact Benefits:** When an artifact is in a player's possession (their address holds that NFT), the game will recognize it and confer specific benefits. The MetaShrew indexer's state can easily keep track of which address owns which artifact (since transfers of these NFTs would be tracked as part of the asset's state). The game contract can check, for example, `inventory/<player>/<artifactID>` or query the artifact's asset balance for the player, to determine if the player has it. Benefits could include:

* **Passive Buffs:** E.g. If you hold the *Ring of Energy*, your energy regen might be effectively 1 point per 4 blocks instead of 5 (the contract, upon calculating regen, could give a bonus if it detects this artifact, or perhaps it reduces the energy cost of actions by 20%). Another example: an artifact could reduce the token cost for certain actions (the contract would then require fewer ENO tokens from you for that action if artifact present).
* **Access Unlocks:** Some encrypted lore or special governor interactions might require having a certain artifact. For instance, maybe the *Key of Secrets NFT* is needed to even initiate dialogue with the Secret Governor beyond a point – the contract would enforce that by checking your inventory before allowing the `InteractGovernor` to proceed for that particular governor beyond rep X. Also, holding a specific artifact might unlock a *new branch of dialogue* in an interaction; the contract could output different dialog indexes if an artifact is held (e.g. the governor notices you have the Amulet of XYZ and gives a unique response).
* **Quest Items:** Some artifacts might be "consumed" or used within quests. The contract could have a function like `UseArtifact(artifactID)` that burns the NFT (transfers it to a burn address) in exchange for some significant in-game effect (perhaps summoning a powerful entity or completing a difficult quest instantly). Because NFTs are tradable, a player could even buy such an artifact from another player to use it for that purpose.
* **Trade and Player Economy:** Artifacts being tradable means there is a **player-driven economy on top of the game**. A player who earns a rare artifact can sell it to others for Enochian tokens or even BTC. This trading would likely happen on Ordinal marketplaces or via atomic swaps, but since the state is tracked by the indexer, the game can reflect the new owner's possession immediately. Nothing special is needed in the contract for trading; ownership is just determined by UTXO control. However, to facilitate easy trade, the game might inscribe each artifact with proper metadata so marketplaces can recognize them (essentially following the emerging standards for ordinal NFTs with provenance).
* **Limited Supply and Rarity:** The game developers will decide how many of each artifact exist. Some could be unique (1 of 1), others could have small sets (e.g. 21 copies of a lesser artifact). Because the contract can enforce conditions on minting (e.g. do not mint if already 1 exists, or only mint one per player or per event), the scarcity is guaranteed by on-chain rules, not just by off-chain policy.

**Logging and Provenance:** Whenever an artifact is awarded, it's logged in the game state (e.g. `log/<player>` entry "Received Artifact X at block N"). The NFT inscription itself also serves as an immutable record of its creation and history, as the Bitcoin transaction data will show its mint and any transfers. The MetaShrew indexer provides **asset views** so one can query, for instance, "who owns artifact #35 now" or "list all artifacts owned by Alice". These are important for both gameplay (the contract checking conditions) and for players to verify authenticity of items. Since all artifact data is on-chain, there is no way to counterfeit an item or hack one into existence outside the rules – the indexer will simply ignore anything that doesn't follow the Alkanes contract logic for item creation.

**Aesthetic Integration:** In keeping with the 16-bit SNES occult aesthetic, artifact NFTs likely come with pixel art representations. These images would be inscribed as part of the NFT's Ordinal data. The game UI can fetch the image from the Bitcoin node or a mirror and display it in the player's inventory screen. Despite their retro look, these artifacts are digital assets on the cutting edge of Bitcoin's capabilities – combining the nostalgia of SNES-era art with the novelty of on-chain gaming.

## State Management and Trac P2P Network Considerations

Managing complex game state on Bitcoin requires careful design due to the UTXO model and distributed P2P consensus. The Trac P2P Network is crucial here as it validates hypertoken evolution through peer consensus for each new block and maintains the **authoritative distributed state**. Some key aspects of state management in our game:

* **State Structure:** We use a hierarchical key-value scheme for state entries:

  * Player-specific data: e.g. `rep/<playerAddr>/<govId> -> int` for reputation, `energy/<playerAddr> -> int` for current energy, `energyLastUpdate/<playerAddr> -> int` for last energy calc block, `claimed/<playerAddr>/<milestoneId> -> bool` for whether a reward claimed, `inventory/<playerAddr>/<artifactId> -> bool` for artifact possession (though this might be redundant since asset tracking is separate, but we could mirror it for quick checks).
  * Governor-specific data: e.g. `lastInteract/<playerAddr>/<govId> -> int block` as discussed, `state/<playerAddr>/<govId> -> small int` for narrative state with that governor.
  * Global data: e.g. `treasuryBalance -> int` (if we track remaining token reserve), or game-wide event flags (like `global/<eventId> -> bool` if a global puzzle is solved).
  * Log data: e.g. `log/<playerAddr>/<n> -> bytes` storing a short encoded event description. (We might cap the log length per player to prevent unbounded growth – possibly only store the latest N events or significant milestones.)
  * Artifact metadata: If needed, though artifact state can mostly be derived from the asset itself, we might still have entries like `artifact/<artifactId>/owner -> playerAddr` to quickly query ownership, or an index of which artifacts a player has (to iterate easily).
  * Token balances: If using Alkanes token balances, those are tracked by the indexer inherently as part of the asset's state. We can query those via MetaShrew's asset view rather than duplicating in our custom state.

* **MetaShrew Indexer Use:** The indexer runs our contract's `_start()` function on each new block or each relevant transaction. It provides the block data (height and serialized block) to the contract, enabling us to use block height for timing and block hash for randomness. Our contract uses MetaShrew's standard library functions to get and set state safely, ensuring that all changes are atomic and cached until committed (so we don't have inconsistent reads/writes mid-run). The `_flush()` is called at the end of processing a block's batch of game transactions to commit the changes. If multiple game transactions occur in the same block, the indexer will process them sequentially (the exact order might be by transaction index in block, which is fine as all are independent player actions typically). MetaShrew guarantees deterministic execution given the same block data and transaction set, so all indexers arrive at the same state.

* **Scalability:** Key-value lookups in the indexer are efficient, and by structuring keys in a logical way, we can retrieve data by prefixes. For example, an explorer or the game UI might want "all governors and rep of player X"; with keys organized under `rep/X/...` this becomes a simple range query. Similarly, to get all players who interacted with Governor 5 recently, one could scan `lastInteract/*/5`. The indexer likely supports such queries via its JSON-RPC (metashrew-view) interface for the front-end. Logging and debugging can be done by running the indexer in a debug mode to see console logs we inserted in the contract (used during development to verify state transitions).

* **Consistency and Reorgs:** Since Bitcoin can have chain reorgs, the MetaShrew indexer is built to handle rollback of state if a block is orphaned. The contract's use of success/failure outputs also helps ensure that a transaction either fully applies or not at all, which aligns with Bitcoin's eventual consistency. The state commitments are tied to block height and transaction IDs, so if those disappear in a reorg, the indexer will rewind and reapply the correct sequence. In effect, the game state follows the longest chain – if some player action gets reorged out, it's as if it never happened in the game (which is expected in a fully on-chain game).

* **Security:** By keeping state changes confined to what the contract allows and using the indexer's deterministic execution, we avoid many traditional game cheating vectors. Players cannot "fake" a higher rep or extra tokens unless they actually perform the on-chain actions to earn them, since the source of truth is the Bitcoin chain plus contract logic. The indexer will ignore any malformed or unauthorized transactions (e.g. someone trying to call a contract function with insufficient tokens or out-of-cycle) – those transactions simply won't match the protocol's rules and thus won't be indexed as valid game actions. This security model is similar to how miners/validators enforce rules in other blockchains, but here it's the custom indexer enforcing game rules on top of Bitcoin consensus data.

* **Upgrades:** A note on evolution: If down the road the game needs a change (say, rebalance token costs or fix a bug), Alkanes allows deploying new contracts and even calling one contract from another. We could deploy a v2 contract and migrate state to it, or use an upgradeable pattern via delegation. Initially, the game contract will likely be set as non-upgradeable to maintain trust (or upgradeable via a governance NFT held by devs for emergency fixes). The design should include a plan for upgrades that is transparent – possibly even an on-chain governance by players (though that might be complex). MetaShrew indexer would then switch to tracking the new logic if the old contract calls the new one. This ensures the game can adapt while staying on-chain.

## Conclusion

**Enochian Governors** is an experimental showcase of what's possible with Bitcoin's emerging meta-protocol stack. By using TAP Protocol hypertokens and the Trac P2P Network, we achieve a fully on-chain RPG with complex state, something once thought impossible on Bitcoin. The game marries *occult lore and retro art* with *cutting-edge blockchain tech*, creating a dark fantasy world secured by the Bitcoin network. Players interact with 91 mystical governors, manage resources like energy and tokens, and uncover secrets – all through Bitcoin transactions that inscribe their journey onto the blockchain's immutable history.

This design emphasizes **transparency** (all game rules and data are on-chain and verifiable), **persistence** (the game can run as long as Bitcoin runs, since the rules and content live on in inscriptions), and **player ownership** (items and tokens are truly owned by players as digital assets). The economy is carefully crafted to be sustainable by balancing token sinks (burns via actions) with sources (treasury rewards), and by leveraging the uniqueness of Bitcoin's block data for randomness and timing (ensuring fairness and a global "tick" to the game's progression).

By following an *interface-first approach*, we outlined how players experience the game (actions, costs, outcomes) and then mapped that to on-chain transactions and state changes. Each element – from the daily interaction limit to the encrypted lore – was considered in terms of on-chain enforceability. The result is a comprehensive blueprint for an on-chain game that is at once a **social experiment** (with players possibly cooperating to solve global puzzles), an **economic experiment** (with a mini economy in tokens and NFTs), and a **technical experiment** pushing Bitcoin to new frontiers.

Ultimately, this Enochian game demonstrates the potential of **Autonomous Worlds** on Bitcoin: self-contained game worlds where the blockchain is the server, the source of randomness, and the arbiter of truth. Players need only a Bitcoin wallet to participate, and they can trust that the game runs as coded, since anyone can join the Trac P2P Network and validate hypertoken evolution state. This fusion of magic-themed gameplay with Bitcoin's grounded technological trust may very well inspire a new genre of on-chain games, where lore and code intertwine and every quest is immortalized in the ledger of Satoshi.

**Sources:** The design above references the TAP Protocol (programmable hypertokens via Bitcoin L1) and the Trac P2P Network's capabilities for distributed state management and consensus validation. The one-transaction interaction model is enabled by TAP Protocol's use of OP\_RETURN messages and hypertoken evolution, avoiding per-action inscriptions. We leverage block data access for randomness and block height for time gating. State and storage utilize Trac P2P Network's distributed consensus system with structured keys for logs and lists. The initial token distribution approach is informed by examples like TAP Protocol's genesis hypertoken patterns, tailored here for a P2P game economy. All content and assets are on-chain in line with Ordinals' philosophy, ensuring a trustless, decentralized gaming experience.
